---
title: "CMAR Coastal Monitoring Program: Data Explorer"
format: 
  dashboard:
    orientation: columns
server: shiny
echo: false
---

```{r}
#| context: setup
#| include: false

# DO NOT UPDATE GGPLOT OR ELSE THE PANEL OUTLINES WILL BE LOST
#remotes::install_version("ggplot2", version = "3.5.2", repos = "http://cran.us.r-project.org")
# https://stackoverflow.com/questions/79771972/why-is-editing-the-panel-border-not-working-inside-ggplotly-wrapper
# issue to submitted to ggplot2 and ggplotly

# Can't deploy
# https://forum.posit.co/t/shinyapps-support-for-r-4-5-0-ubuntu-24-04-jammy/199608

# Dynamic UI
# https://mastering-shiny.org/action-dynamic.html

library(DT)
library(dplyr)
library(ggplot2)
library(here)
library(htmlwidgets)
library(leaflet)
library(lubridate)
library(plotly)
library(RColorBrewer)
library(sensorstrings)
library(shiny)

source(here("functions/add_map_layers.R"))
source(here("functions/helpers.R"))

theme_set(theme_light())

dat_all <- readRDS(here("data/cmp_time_series_dates.RDS"))

dat_gap <- readRDS(here("data/cmp_time_series_gaps.RDS")) %>% 
  mutate(gap_length_weeks = round(gap_length_days / 7))

st_locations <- readRDS(here("data/cmp_station_locations.RDS"))

get_pal <- colorRampPalette(brewer.pal(8, "Dark2"))
county_pal <- get_pal(length(unique(dat_all$county)))

```

# Filters {.sidebar width=20% height=100%}

```{r}
#| title: Select

w <- '95%'

sliderInput(
  inputId = "min_ts_length",
  "Select Min Time Series Length (weeks)",
  min = 0, max = round(max(dat_all$ts_length_weeks), digits = -1), 
  value = round(min(dat_all$ts_length_weeks), digits = -1), 
  step = 1, width = w, ticks = TRUE
)

sliderInput(
  inputId = "max_data_gap",
  "Select Max Acceptable Data Gap (weeks)",
  min = 0, max = round(max(dat_gap$gap_length_weeks), digits = -1), 
  value = round(max(dat_gap$gap_length_weeks), digits = -1), 
  step = 1, width = w, ticks = TRUE
)

uiOutput("county_dropdown")

uiOutput("station_dropdown")
uiOutput("depth_dropdown")
```

# Station Map
```{r}
leafletOutput("fig_map")
```

# County 
```{r}
#| class-output: scrollable-plot

plotlyOutput("fig_county")
```

# Station & Depth 
```{r}
#| class-output: scrollable-plot
#| width: 100%

plotlyOutput("fig_station_depth")
```

# Download Table
```{r}
DTOutput("table_station_depth")
```

# Read Me

More info to come.

**Inputs**

  - Select Min Time Series Length (weeks): move slider to choose the minimum length of the time series based on the start date and end date of deployment.
  - Select Max Acceptable Data Gap (weeks): move slider to choose the maximum  acceptable length of a gap in a time series (data from a single station at a single depth).
  - Select County: choose the county or counties of interest. 
  - Select Station(s): choose the station(s) of interest. The options update based on the inputs above. *The station dropdown will reset to "All" when the inputs above are adjusted.* 
  - Select Depth(s): choose the depth(s) of interest. The options update based on the inputs above. *The depth dropdown will reset to "All" when the inputs above are adjusted.*

For the dropdown inputs:

  - Click "All" to choose all options. 
  - To remove a selection, click on it and press "delete" on your keyboard.
  - Make sure to delete "All" before clicking on a different selection or the filter will not be applied.


**Tabs**

- Station Map: location of stations with data based on the input criteria. The "Sensor Depth (m)" panel can be used to filter the depths shown on the map. This will not impact the depths shown on any of the other tabs. Note that the depths are not always shown in numeric order.
- County: chart of when data was collected at each selected station and county, regardless of depth. 
- Station & Depth: chart of when data was collected at each selected station and depth. The legend on the right can be used to filter the depths show on the chart. This will not impact any of the other tabs.
- Download Table: shows the time series corresponding to the input criteria, including the start and end dates and length. Can be downloaded by clicking the "CSV" button in the top left.

**Known Issues**

- If the inputs result in no data to plot, the Station Map and figures will freeze on the last version of the figure *with no error*. However, the Download Table will display the message "No data available in table." If the figures are not behaving as expected, check the Download Table to see if there is anything to plot.


```{r}
#| context: server

dat_county <- reactive({
  req(input$selected_county)
  
  gaps_large <- dat_gap %>%
    filter(gap_length_weeks > input$max_data_gap)
  
  if ("All" %in% input$selected_county) { 
    sel_county <- unique(dat_all$county) 
  } else { sel_county <- input$selected_county }
  
  dat_county <- dat_all %>% 
    filter(
      county %in% sel_county,
      ts_length_weeks >= input$min_ts_length
    ) %>%
    anti_join(
      gaps_large, by = join_by(county, station, sensor_depth_at_low_tide_m)
    )
  
  return(dat_county) # use this to make the options for station_dropdown
})


dat_station <- reactive({
  req(input$selected_station)
  
   # gaps_large <- dat_gap %>%
   #   filter(gap_length_weeks > input$max_data_gap)
  
  if ("All" %in% input$selected_station) { 
    sel_station <- unique(dat_county()$station) 
  } else { sel_station <- input$selected_station }
  
  dat_station <- dat_county() %>% 
    filter(
      station %in% sel_station)
    #   ts_length_weeks >= input$min_ts_length
    # ) %>%
    # anti_join(
    #   gaps_large, by = join_by(county, station, sensor_depth_at_low_tide_m)
    # )
  
  return(dat_station) # use this to make the options in the depth dropdown
})

dat_depth <- reactive({
  req(input$selected_depth)
  
  if ("All" %in% input$selected_depth) { 
    sel_depth <- unique(dat_station()$sensor_depth_at_low_tide_m) 
  } else { sel_depth <- input$selected_depth }
  
  dat_depth <- dat_station() %>%
    filter(sensor_depth_at_low_tide_m %in% sel_depth)
  
  return(dat_depth)
})

########################################################
#### UI ################################################
########################################################
output$county_dropdown <- renderUI({
  selectInput(
    inputId = "selected_county", "Select County", 
    selected = "All",
    choices = c("All", sort(unique(dat_all$county))),
    multiple = TRUE
  )
})

# station dropdown
output$station_dropdown <- renderUI({
  selectInput(
    inputId = "selected_station", "Select Station(s)", 
    selected = "All",
    choices = NULL,
    multiple = TRUE
  )
})

# update station dropdown
observeEvent(dat_county(), {
  if(is.null(input$selected_station)) {
    selected <- "All"
  } else selected <- isolate(input$selected_station)
  
  choices <- c("All", sort(unique(dat_county()$station)))
  
  updateSelectInput(
    inputId = "selected_station", choices = choices, selected = selected
  )
})

# depth dropdown
output$depth_dropdown <- renderUI({
  selectInput(
    inputId = "selected_depth", "Select Depth(s)", 
    choices = NULL, multiple = TRUE
  )
})

# update depth dropdown
observeEvent(dat_station(), {
  
  if(is.null(input$selected_depth)) {
    selected <- "All"
  } else selected <- isolate(input$selected_depth)
  
  choices <- c("All", sort(unique(dat_station()$sensor_depth_at_low_tide_m)))
  
  updateSelectInput(
    inputId = "selected_depth", choices = choices, selected = selected
  )
})

########################################################
#### Figures ###########################################
########################################################
output$fig_map <- renderLeaflet({
  validate(
    need(nrow(dat_depth()) > 0, "No stations to map. Please adjust filters.")
  )

  st_dat <- st_locations %>%
    inner_join(
      dat_depth(),
      by = join_by(county, station, sensor_depth_at_low_tide_m)
    ) %>%
    mutate(
      popup = paste(
        "station: ", station, "</br>",
        "depth_m: ", sensor_depth_at_low_tide_m)
    )
  
  depth_pal <- colorNumeric(
    palette = ss_get_colour_palette(st_dat),
    domain = unique(st_dat$sensor_depth_at_low_tide_m)
  )
  st_map <- split(st_dat, st_dat$sensor_depth_at_low_tide_m)

  leaflet() %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    add_map_layers(
      map_dat = st_map,
      popup = ~popup,
      size = 4,
      map_pal = ~depth_pal(sensor_depth_at_low_tide_m)
    ) %>%
    addScaleBar(
      position = "bottomleft",
      options = scaleBarOptions(imperial = FALSE)
    ) %>%
    addLayersControl(
      overlayGroups = unique(st_dat$sensor_depth_at_low_tide_m),
      options = layersControlOptions(collapsed = FALSE),
      position = "bottomright"
    ) %>%
    htmlwidgets::onRender(
      "function() {$('.leaflet-control-layers-overlays').
    prepend('<label style=\"text-align:center\">Sensor Depth (m)</label>');}"
    )
})


output$fig_county <- renderPlotly({
  # validate(
  #   need(nrow(dat_depth()) > 0, "No data to plot. Please adjust filters.")
  # )
  
  # better to use dat_depth here than input$county because dat_depth() already
  # dealt with the "All" option
  county_vec <- unique(dat_depth()$county)
  h <- get_county_fig_height(county_vec)

  dat_plot <- dat_depth() %>%
    mutate(county = ordered(county, levels = sort(unique(dat_all$county))))

  p <- ggplot(dat_plot, aes(colour = county)) +
    geom_segment(
      aes(
        x = start_date, xend = end_date, y = station, yend = station,
        text = paste(
          "station: ", station, "\n",
          "start_date: ", as_date(start_date), "\n",
          "end_date: ", as_date(end_date), "\n",
          "length_weeks: ", round(ts_length_weeks))
      ), linewidth = 4
    ) +
    scale_y_discrete(limits = rev) +
    scale_colour_manual(values = county_pal, drop = FALSE) +
    facet_wrap(~county, scales = "free_y", ncol = 1) +
    theme(
      legend.position = "none",
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.border = element_rect(colour = "gray20"),
      strip.background = element_rect(colour = "gray20", fill = "gray40"),
      panel.spacing.x = unit(-1, "lines")
    )

  ggplotly(p, tooltip = "text", height = h) %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "cmar_county_time_series",
        width = 1200, height = h
      ))
})

output$fig_station_depth <- renderPlotly({
  
  # better to use dat_depth here than input$county because dat_depth() already
  # dealt with the "All" option
  station_vec <- unique(dat_depth()$station)
  h <- get_station_fig_height(station_vec)
  
  dat_plot <- dat_depth() %>%
    ss_convert_depth_to_ordered_factor()
  
  p <- ggplot(dat_plot, aes(col = sensor_depth_at_low_tide_m)) +
    geom_segment(
      aes(
        x = start_date, xend = end_date,
        y = sensor_depth_at_low_tide_m, yend = sensor_depth_at_low_tide_m,
        text = paste(
          "station: ", station, "\n",
          "depth_m: ", sensor_depth_at_low_tide_m, "\n",
          "start_date: ", as_date(start_date), "\n",
          "end_date: ", as_date(end_date), "\n",
          "length_weeks: ", round(ts_length_weeks))
      ), linewidth = 4
    ) +
    scale_y_discrete(
      limits = rev(levels(dat_plot$sensor_depth_at_low_tide_m))
    ) +
    scale_colour_manual("Depth (m)", values = ss_get_colour_palette(dat_plot)) +
    facet_wrap(~station) +
    theme(
      axis.title.x = element_blank(),
      panel.spacing.x = unit(0, "lines"),
      axis.title.y = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(colour = "gray20"),
      strip.background = element_rect(colour = "gray20", fill = "gray40")
    ) 
  
  ggplotly(p, tooltip = "text", height = h) %>% 
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "cmar_station_depth_time_series",
        width = 1200, height = h
      ))
})

output$table_station_depth <- renderDT({
  dat_depth() %>% 
    mutate(start_date = format(start_date), end_date = format(end_date)) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
        buttons = list(
          list(extend = 'csv', title = "station_depth_data_series") 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
})

```




