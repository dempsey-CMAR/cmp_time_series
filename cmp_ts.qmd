---
title: "CMAR Coastal Monitoring Program"
format: 
  dashboard:
    orientation: columns
server: shiny
echo: false
---

```{r}
#| context: setup
#| include: false

# DO NOT UPDATE GGPLOT OR ELSE THE PANEL OUTLINES WILL BE LOST
#remotes::install_version("ggplot2", version = "3.5.2", repos = "http://cran.us.r-project.org")
# https://stackoverflow.com/questions/79771972/why-is-editing-the-panel-border-not-working-inside-ggplotly-wrapper
# issue to submitted to ggplot2 and ggplotly

library(DT)
library(dplyr)
library(ggplot2)
library(here)
library(htmlwidgets)
library(leaflet)
library(lubridate)
library(plotly)
library(RColorBrewer)
library(sensorstrings)
library(shiny)

source(here("functions/add_map_layers.R"))
source(here("functions/helpers.R"))

theme_set(theme_light())

dat_all <- readRDS(here("data/cmp_time_series_dates.RDS"))

dat_gap <- readRDS(here("data/cmp_time_series_gaps.RDS")) %>% 
  mutate(gap_length_weeks = round(gap_length_days / 7))

st_locations <- readRDS(here("data/cmp_station_locations.RDS"))

get_pal <- colorRampPalette(brewer.pal(8, "Dark2"))
county_pal <- get_pal(length(unique(dat_all$county)))

```


# Filters {.sidebar width=20% height=100%}

```{r}
#| title: Select

w <- '95%'

sliderInput(
  inputId = "min_ts_length",
  "Select Min Time Series Length (weeks)",
  min = 0, max = round(max(dat_all$ts_length_weeks), digits = -1), 
  value = round(min(dat_all$ts_length_weeks), digits = -1), 
  step = 1, width = w, ticks = TRUE
)

sliderInput(
  inputId = "max_data_gap",
  "Select Max Acceptable Data Gap (weeks)",
  min = 0, max = round(max(dat_gap$gap_length_weeks), digits = -1), 
  value = round(max(dat_gap$gap_length_weeks), digits = -1), 
  step = 1, width = w, ticks = TRUE
)

uiOutput("county_dropdown")
uiOutput("station_dropdown")
#uiOutput("depth_checkbox")

```

# Station Map
```{r}
leafletOutput("fig_map")
```

# County 
```{r}
#| class-output: scrollable-plot

plotlyOutput("fig_county")
```

# Station & Depth 
```{r}
#| class-output: scrollable-plot

plotlyOutput("fig_station_depth")
```

# Download Table
```{r}
DTOutput("table_station_depth")
```


```{r}
#| context: server

dat_county <- reactive({
  req(input$selected_county)
  
  if ("All" %in% input$selected_county) { 
    sel_county <- unique(dat_all$county) 
  } else { sel_county <- input$selected_county }
  
  dat_county <- dat_all %>% 
    filter(county %in% sel_county) 
  
  return(dat_county) # use this to make the options for station_dropdown
})

dat_station <- reactive({
  req(input$selected_station)
  
  gaps_large <- dat_gap %>%
    filter(gap_length_weeks > input$max_data_gap)
  
  if ("All" %in% input$selected_station) { 
    sel_station <- unique(dat_county()$station) 
  } else { sel_station <- input$selected_station }
  
  dat_station <- dat_county() %>% 
    filter(
      station %in% sel_station,
      ts_length_weeks >= input$min_ts_length
    ) %>% 
    anti_join(
      gaps_large, by = join_by(county, station, sensor_depth_at_low_tide_m)
    )
  
  return(dat_station)
})

# dat_depth <- reactive({
#   req(input$selected_depth)
#   
#   dat_depth <- dat_station() %>% 
#     filter(sensor_depth_at_low_tide_m %in% input$selected_depth)
#   
#   return(dat_depth)
# })


# UI
output$county_dropdown <- renderUI({
  selectInput(
    inputId = "selected_county", "Select County", selected = "Annapolis",
    choices = c("All", sort(unique(dat_all$county))),
    multiple = TRUE
  )
})

output$station_dropdown <- renderUI({
  selectInput(
    inputId = "selected_station", "Select Station(s)", selected = "All",
    choices = c("All", sort(unique(dat_county()$station))),
    multiple = TRUE
  )
})

# output$depth_checkbox <- renderUI({
#   checkboxGroupInput(
#     inputId = "selected_depth", "Select Depth(s)",
#     selected = sort(unique(dat_station()$sensor_depth_at_low_tide_m)),
#     choices = sort(unique(dat_station()$sensor_depth_at_low_tide_m))
#   )
# })

output$check_data <- renderTable({
  validate(
    need(nrow(dat_station()) > 0, "No stations to map. Please adjust filters.")
  )
  
  dat_station()
})

# figures
output$fig_map <- renderLeaflet({
  validate(
    need(nrow(dat_station()) > 0, "No stations to map. Please adjust filters.")
  )

  st_dat <- st_locations %>%
    inner_join(
      dat_station(),
      by = join_by(county, station, sensor_depth_at_low_tide_m)
    ) %>%
    ss_convert_depth_to_ordered_factor() %>%
      mutate(
    popup = paste(
      "station: ", station, "</br>",
      "depth_m: ", sensor_depth_at_low_tide_m
    )
  )

  
  depth_pal <- colorFactor(
    palette = ss_get_colour_palette(st_dat),
    domain = levels(st_dat$sensor_depth_at_low_tide_m)
  )
  # won't need this or add_map_layers when depth filter added
  st_map <- split(st_dat, st_dat$sensor_depth_at_low_tide_m)

  m <- leaflet() %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    add_map_layers(
      map_dat = st_map,
      popup = ~popup,
      size = 4,
      map_pal = ~depth_pal(sensor_depth_at_low_tide_m)
    ) %>%
    addScaleBar(
      position = "bottomright",
      options = scaleBarOptions(imperial = FALSE)
    ) %>%
    addLayersControl(
      overlayGroups = levels(st_dat$sensor_depth_at_low_tide_m),
      options = layersControlOptions(collapsed = FALSE),
      position = "bottomleft"
    ) %>% 
      htmlwidgets::onRender("
        function() {
            $('.leaflet-control-layers-overlays').prepend('<label style=\"text-align:center\">Sensor Depth (m)</label>');
        }
    ")

  return(m)
})


output$fig_county <- renderPlotly({
  # validate(
  #   need(nrow(dat_station()) > 0, "No data to plot. Please adjust filters.")
  # )
  
  # better to use dat_station here than input$county because dat_station() already
  # dealt with the "All" option
  county_vec <- unique(dat_station()$county)
  h <- get_county_fig_height(county_vec)

  dat_plot <- dat_station() %>%
    mutate(county = ordered(county, levels = sort(unique(dat_all$county))))

  p <- ggplot(dat_plot, aes(colour = county)) +
    geom_segment(
      aes(
        x = start_date, xend = end_date, y = station, yend = station,
        text = paste(
          "station: ", station, "\n",
          "start_date: ", as_date(start_date), "\n",
          "end_date: ", as_date(end_date), "\n",
          "length_weeks: ", round(ts_length_weeks))
      ), linewidth = 4
    ) +
    scale_y_discrete(limits = rev) +
    scale_colour_manual(values = county_pal, drop = FALSE) +
    facet_wrap(~county, scales = "free_y", ncol = 1) +
    theme(
      legend.position = "none",
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.border = element_rect(colour = "gray20"),
      strip.background = element_rect(colour = "gray20", fill = "gray40"),
      panel.spacing.x = unit(-1, "lines")
    )

  ggplotly(p, tooltip = "text", height = h) %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "cmar_county_time_series",
        width = 1200, height = h
      ))
})

output$fig_station_depth <- renderPlotly({
  
  # better to use dat_station here than input$county because dat_station() already
  # dealt with the "All" option
  station_vec <- unique(dat_station()$station)
  h <- get_station_fig_height(station_vec)
  
  dat_plot <- dat_station() %>%
    ss_convert_depth_to_ordered_factor()
  
  p <- ggplot(dat_plot, aes(col = sensor_depth_at_low_tide_m)) +
    geom_segment(
      aes(
        x = start_date, xend = end_date,
        y = sensor_depth_at_low_tide_m, yend = sensor_depth_at_low_tide_m,
        text = paste(
          "station: ", station, "\n",
          "depth_m: ", sensor_depth_at_low_tide_m, "\n",
          "start_date: ", as_date(start_date), "\n",
          "end_date: ", as_date(end_date), "\n",
          "length_weeks: ", round(ts_length_weeks))
      ), linewidth = 4
    ) +
    scale_y_discrete(
      limits = rev(levels(dat_plot$sensor_depth_at_low_tide_m))
    ) +
    scale_colour_manual("Depth (m)", values = ss_get_colour_palette(dat_plot)) +
    facet_wrap(~station) +
    theme(
      axis.title.x = element_blank(),
      panel.spacing.x = unit(0, "lines"),
      axis.title.y = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(colour = "gray20"),
      strip.background = element_rect(colour = "gray20", fill = "gray40")
    ) 
  
  ggplotly(p, tooltip = "text", height = h) %>% 
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "cmar_station_depth_time_series",
        width = 1200, height = h
      ))
})

output$table_station_depth <- renderDT({
  dat_station() %>% 
    mutate(start_date = format(start_date), end_date = format(end_date)) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
        buttons = list(
          list(extend = 'csv', title = "station_depth_data_series") 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
})

```




